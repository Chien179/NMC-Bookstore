// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: revenue.sql

package db

import (
	"context"
	"time"
)

const revenueDays = `-- name: RevenueDays :many
SELECT
COALESCE(SUM(subtotal), 0) AS revenue_days,
COALESCE(AVG(subtotal), 0) AS avg_revenue_days,  
to_char(date(created_at),'YYYY-MM-DD') as dates
FROM payments
WHERE status = 'success'
GROUP BY dates
ORDER BY dates
`

type RevenueDaysRow struct {
	RevenueDays    interface{} `json:"revenue_days"`
	AvgRevenueDays interface{} `json:"avg_revenue_days"`
	Dates          string      `json:"dates"`
}

func (q *Queries) RevenueDays(ctx context.Context) ([]RevenueDaysRow, error) {
	rows, err := q.db.QueryContext(ctx, revenueDays)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RevenueDaysRow{}
	for rows.Next() {
		var i RevenueDaysRow
		if err := rows.Scan(&i.RevenueDays, &i.AvgRevenueDays, &i.Dates); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revenueHours = `-- name: RevenueHours :many
SELECT
COALESCE(SUM(subtotal), 0) AS revenue_days,
COALESCE(AVG(subtotal), 0) AS avg_revenue_days,  
created_at
FROM payments
WHERE status = 'success'
GROUP BY created_at
ORDER BY created_at
`

type RevenueHoursRow struct {
	RevenueDays    interface{} `json:"revenue_days"`
	AvgRevenueDays interface{} `json:"avg_revenue_days"`
	CreatedAt      time.Time   `json:"created_at"`
}

func (q *Queries) RevenueHours(ctx context.Context) ([]RevenueHoursRow, error) {
	rows, err := q.db.QueryContext(ctx, revenueHours)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RevenueHoursRow{}
	for rows.Next() {
		var i RevenueHoursRow
		if err := rows.Scan(&i.RevenueDays, &i.AvgRevenueDays, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revenueMonths = `-- name: RevenueMonths :many
SELECT
COALESCE(SUM(subtotal), 0) AS revenue_months,
COALESCE(AVG(subtotal), 0) AS avg_revenue_months,
to_char(date(created_at),'YYYY-MM') as year_months
FROM payments
WHERE status = 'success'
GROUP BY year_months
ORDER BY year_months
`

type RevenueMonthsRow struct {
	RevenueMonths    interface{} `json:"revenue_months"`
	AvgRevenueMonths interface{} `json:"avg_revenue_months"`
	YearMonths       string      `json:"year_months"`
}

func (q *Queries) RevenueMonths(ctx context.Context) ([]RevenueMonthsRow, error) {
	rows, err := q.db.QueryContext(ctx, revenueMonths)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RevenueMonthsRow{}
	for rows.Next() {
		var i RevenueMonthsRow
		if err := rows.Scan(&i.RevenueMonths, &i.AvgRevenueMonths, &i.YearMonths); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revenueQuarters = `-- name: RevenueQuarters :many
SELECT
COALESCE(SUM(subtotal), 0) AS revenue_quarters,
COALESCE(AVG(subtotal), 0) AS avg_revenue_quarters,
to_char(date(created_at),'YYYY-Q') as year_quarters
FROM payments
WHERE status = 'success'
GROUP BY year_quarters
ORDER BY year_quarters
`

type RevenueQuartersRow struct {
	RevenueQuarters    interface{} `json:"revenue_quarters"`
	AvgRevenueQuarters interface{} `json:"avg_revenue_quarters"`
	YearQuarters       string      `json:"year_quarters"`
}

func (q *Queries) RevenueQuarters(ctx context.Context) ([]RevenueQuartersRow, error) {
	rows, err := q.db.QueryContext(ctx, revenueQuarters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RevenueQuartersRow{}
	for rows.Next() {
		var i RevenueQuartersRow
		if err := rows.Scan(&i.RevenueQuarters, &i.AvgRevenueQuarters, &i.YearQuarters); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revenueYears = `-- name: RevenueYears :many
SELECT
COALESCE(SUM(subtotal), 0) AS revenue_years,
COALESCE(AVG(subtotal), 0) AS avg_revenue_years,
to_char(date(created_at),'YYYY') as years
FROM payments
WHERE status = 'success'
GROUP BY years
ORDER BY years
`

type RevenueYearsRow struct {
	RevenueYears    interface{} `json:"revenue_years"`
	AvgRevenueYears interface{} `json:"avg_revenue_years"`
	Years           string      `json:"years"`
}

func (q *Queries) RevenueYears(ctx context.Context) ([]RevenueYearsRow, error) {
	rows, err := q.db.QueryContext(ctx, revenueYears)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RevenueYearsRow{}
	for rows.Next() {
		var i RevenueYearsRow
		if err := rows.Scan(&i.RevenueYears, &i.AvgRevenueYears, &i.Years); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
