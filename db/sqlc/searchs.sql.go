// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: searchs.sql

package db

import (
	"context"
	"encoding/json"
)

const fullSearch = `-- name: FullSearch :one
SELECT
    (SELECT (COUNT(*)/$1)
        FROM searchs) 
        as total_page, 
    (SELECT JSON_AGG(t.*) FROM (
        SELECT 
            id,
            name,
            price,
            image,
            description,
            author,
            publisher,
            quantity,
            rating,
            created_at
        FROM searchs
        WHERE searchs_tsv @@ plainto_tsquery($2)
            AND searchs.price BETWEEN $3
            AND $4
            AND searchs.rating >= $5
        ORDER BY ts_rank DESC
        LIMIT $1
        OFFSET $6
    ) AS t) AS books
`

type FullSearchParams struct {
	Limit    interface{} `json:"limit"`
	Text     string      `json:"text"`
	MinPrice float64     `json:"min_price"`
	MaxPrice float64     `json:"max_price"`
	Rating   float64     `json:"rating"`
	Offset   int32       `json:"offset"`
}

type FullSearchRow struct {
	TotalPage int32           `json:"total_page"`
	Books     json.RawMessage `json:"books"`
}

func (q *Queries) FullSearch(ctx context.Context, arg FullSearchParams) (FullSearchRow, error) {
	row := q.db.QueryRowContext(ctx, fullSearch,
		arg.Limit,
		arg.Text,
		arg.MinPrice,
		arg.MaxPrice,
		arg.Rating,
		arg.Offset,
	)
	var i FullSearchRow
	err := row.Scan(&i.TotalPage, &i.Books)
	return i, err
}
