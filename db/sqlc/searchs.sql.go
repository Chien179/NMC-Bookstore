// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: searchs.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/lib/pq"
)

const fullSearch = `-- name: FullSearch :one
SELECT t.total_page, JSON_AGG(json_build_object
	('id',id,
	'name',name,
    'price',price,
    'image',image,
    'description',description,
    'author',author,
    'publisher',publisher,
    'quantity',quantity,
    'rating',rating,
    'created_at',created_at)
	) AS books FROM (
        SELECT 
        	CEILING(CAST(COUNT(id) OVER () AS FLOAT)/$1) AS total_page,
            id,
            name,
            price,
            image,
            description,
            author,
            publisher,
            quantity,
            rating,
            created_at,
            ts_rank(searchs_tsv, plainto_tsquery($2)) as ts_rank
        FROM searchs
        WHERE
            searchs.price BETWEEN $3 AND $4
            AND (searchs_tsv @@ plainto_tsquery($2) OR $2 IS NULL)
            AND (searchs.rating >= $5 OR $5 IS NULL)
            AND (searchs.genres_id = $6 OR $6 IS NULL)
            AND (searchs.subgenres_id = $7 OR $7 IS NULL)
        GROUP BY 
        	id,
            name,
            price,
            image,
            description,
            author,
            publisher,
            quantity,
            rating,
            genres_id,
            created_at,
            ts_rank
        ORDER BY ts_rank DESC
        LIMIT $1
        OFFSET $8
        ) AS t
    GROUP BY t.total_page
`

type FullSearchParams struct {
	Limit       int32           `json:"limit"`
	Text        sql.NullString  `json:"text"`
	MinPrice    float64         `json:"min_price"`
	MaxPrice    float64         `json:"max_price"`
	Rating      sql.NullFloat64 `json:"rating"`
	GenresID    sql.NullInt64   `json:"genres_id"`
	SubgenresID sql.NullInt64   `json:"subgenres_id"`
	Offset      int32           `json:"offset"`
}

type FullSearchRow struct {
	TotalPage float64         `json:"total_page"`
	Books     json.RawMessage `json:"books"`
}

func (q *Queries) FullSearch(ctx context.Context, arg FullSearchParams) (FullSearchRow, error) {
	row := q.db.QueryRowContext(ctx, fullSearch,
		arg.Limit,
		arg.Text,
		arg.MinPrice,
		arg.MaxPrice,
		arg.Rating,
		arg.GenresID,
		arg.SubgenresID,
		arg.Offset,
	)
	var i FullSearchRow
	err := row.Scan(&i.TotalPage, &i.Books)
	return i, err
}

const justForYou = `-- name: JustForYou :many
SELECT
	id,
	name,
	price,
	image,
	description,
	author,
	publisher,
	quantity,
	rating,
	created_at
FROM searchs
GROUP BY
	id,
	name,
	price,
	image,
	description,
	author,
	publisher,
	quantity,
	rating,
	created_at
ORDER BY random()
LIMIT 20
`

type JustForYouRow struct {
	ID          int64     `json:"id"`
	Name        string    `json:"name"`
	Price       float64   `json:"price"`
	Image       []string  `json:"image"`
	Description string    `json:"description"`
	Author      string    `json:"author"`
	Publisher   string    `json:"publisher"`
	Quantity    int32     `json:"quantity"`
	Rating      float64   `json:"rating"`
	CreatedAt   time.Time `json:"created_at"`
}

func (q *Queries) JustForYou(ctx context.Context) ([]JustForYouRow, error) {
	rows, err := q.db.QueryContext(ctx, justForYou)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []JustForYouRow{}
	for rows.Next() {
		var i JustForYouRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Price,
			pq.Array(&i.Image),
			&i.Description,
			&i.Author,
			&i.Publisher,
			&i.Quantity,
			&i.Rating,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recommend = `-- name: Recommend :many
SELECT
	id,
	name,
	price,
	image,
	description,
	author,
	publisher,
	quantity,
	rating,
	created_at
FROM searchs
WHERE genres_id = ANY ($1::bigint[])
	AND subgenres_id = ANY ($2::bigint[])
    AND id <> $3
GROUP BY
	id,
	name,
	price,
	image,
	description,
	author,
	publisher,
	quantity,
	rating,
	created_at
ORDER BY random()
LIMIT 40
`

type RecommendParams struct {
	GenresID    []int64 `json:"genres_id"`
	SubgenresID []int64 `json:"subgenres_id"`
	BooksID     int64   `json:"books_id"`
}

type RecommendRow struct {
	ID          int64     `json:"id"`
	Name        string    `json:"name"`
	Price       float64   `json:"price"`
	Image       []string  `json:"image"`
	Description string    `json:"description"`
	Author      string    `json:"author"`
	Publisher   string    `json:"publisher"`
	Quantity    int32     `json:"quantity"`
	Rating      float64   `json:"rating"`
	CreatedAt   time.Time `json:"created_at"`
}

func (q *Queries) Recommend(ctx context.Context, arg RecommendParams) ([]RecommendRow, error) {
	rows, err := q.db.QueryContext(ctx, recommend, pq.Array(arg.GenresID), pq.Array(arg.SubgenresID), arg.BooksID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RecommendRow{}
	for rows.Next() {
		var i RecommendRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Price,
			pq.Array(&i.Image),
			&i.Description,
			&i.Author,
			&i.Publisher,
			&i.Quantity,
			&i.Rating,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
