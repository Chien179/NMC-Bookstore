// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: revenue.sql

package db

import (
	"context"
)

const revenueDays = `-- name: RevenueDays :many
SELECT COALESCE(SUM(subtotal), 0) AS sum_revenue,
    COALESCE(AVG(subtotal), 0) AS avg_revenue,
    to_char(date(created_at), 'DD-MM-YYYY') as time_revenue,
    to_char(date(created_at), 'YYYY') as time_year
FROM payments
WHERE status = 'success'
GROUP BY time_revenue,
    time_year
ORDER BY time_year ASC
`

type RevenueDaysRow struct {
	SumRevenue  interface{} `json:"sum_revenue"`
	AvgRevenue  interface{} `json:"avg_revenue"`
	TimeRevenue string      `json:"time_revenue"`
	TimeYear    string      `json:"time_year"`
}

func (q *Queries) RevenueDays(ctx context.Context) ([]RevenueDaysRow, error) {
	rows, err := q.db.QueryContext(ctx, revenueDays)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RevenueDaysRow{}
	for rows.Next() {
		var i RevenueDaysRow
		if err := rows.Scan(
			&i.SumRevenue,
			&i.AvgRevenue,
			&i.TimeRevenue,
			&i.TimeYear,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revenueMonths = `-- name: RevenueMonths :many
SELECT COALESCE(SUM(subtotal), 0) AS sum_revenue,
    COALESCE(AVG(subtotal), 0) AS avg_revenue,
    to_char(date(created_at), 'MM-YYYY') as time_revenue,
    to_char(date(created_at), 'YYYY') as time_year
FROM payments
WHERE status = 'success'
GROUP BY time_revenue,
    time_year
ORDER BY time_year ASC
`

type RevenueMonthsRow struct {
	SumRevenue  interface{} `json:"sum_revenue"`
	AvgRevenue  interface{} `json:"avg_revenue"`
	TimeRevenue string      `json:"time_revenue"`
	TimeYear    string      `json:"time_year"`
}

func (q *Queries) RevenueMonths(ctx context.Context) ([]RevenueMonthsRow, error) {
	rows, err := q.db.QueryContext(ctx, revenueMonths)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RevenueMonthsRow{}
	for rows.Next() {
		var i RevenueMonthsRow
		if err := rows.Scan(
			&i.SumRevenue,
			&i.AvgRevenue,
			&i.TimeRevenue,
			&i.TimeYear,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revenueQuarters = `-- name: RevenueQuarters :many
SELECT COALESCE(SUM(subtotal), 0) AS sum_revenue,
    COALESCE(AVG(subtotal), 0) AS avg_revenue,
    to_char(date(created_at), 'Q-YYYY') as time_revenue,
    to_char(date(created_at), 'YYYY') as time_year
FROM payments
WHERE status = 'success'
GROUP BY time_revenue,
    time_year
ORDER BY time_year ASC
`

type RevenueQuartersRow struct {
	SumRevenue  interface{} `json:"sum_revenue"`
	AvgRevenue  interface{} `json:"avg_revenue"`
	TimeRevenue string      `json:"time_revenue"`
	TimeYear    string      `json:"time_year"`
}

func (q *Queries) RevenueQuarters(ctx context.Context) ([]RevenueQuartersRow, error) {
	rows, err := q.db.QueryContext(ctx, revenueQuarters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RevenueQuartersRow{}
	for rows.Next() {
		var i RevenueQuartersRow
		if err := rows.Scan(
			&i.SumRevenue,
			&i.AvgRevenue,
			&i.TimeRevenue,
			&i.TimeYear,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revenueYears = `-- name: RevenueYears :many
SELECT COALESCE(SUM(subtotal), 0) AS sum_revenue,
    COALESCE(AVG(subtotal), 0) AS avg_revenue,
    to_char(date(created_at), 'YYYY') as time_revenue
FROM payments
WHERE status = 'success'
GROUP BY time_revenue
ORDER BY time_revenue
`

type RevenueYearsRow struct {
	SumRevenue  interface{} `json:"sum_revenue"`
	AvgRevenue  interface{} `json:"avg_revenue"`
	TimeRevenue string      `json:"time_revenue"`
}

func (q *Queries) RevenueYears(ctx context.Context) ([]RevenueYearsRow, error) {
	rows, err := q.db.QueryContext(ctx, revenueYears)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RevenueYearsRow{}
	for rows.Next() {
		var i RevenueYearsRow
		if err := rows.Scan(&i.SumRevenue, &i.AvgRevenue, &i.TimeRevenue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
